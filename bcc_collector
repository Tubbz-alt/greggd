#!/usr/bin/env python
# run a daemon to collect bpf info using bcc

from __future__ import print_function
from collections import defaultdict
from os.path import dirname, join, abspath
from time import sleep, strftime
import argparse
import configargparse
import ctypes as ct
import glob
import importlib
import logging
import os
import socket
import sys
import struct
import threading
import time
import yaml
import communityid

from bcc import ArgString, BPF
from bcc.utils import ArgString, printb
from bcc.table import HashTable

debug = True

sock = None

def fix_tag(value):
    # special characters and keyword replacements for line protocol
    if not isinstance(value, str):
        return value
    value = value.replace(',', '\\,')
    value = value.replace('=', '\\=')
    value = value.replace(' ', '\\ ')
    return value

# telegraf/issues/5460
def fix_field(value):
    # special characters and keyword replacements for line protocol
    if not isinstance(value, str):
        return value
    value = value.replace('\\', '\\\\')
    value = value.replace('"', '\\"')
    return '"{0}"'.format(value)

def send_message(tags, fields):
    tags = dict((k, fix_tag(v)) for k, v in tags.items() if v is not None and v is not "")
    fields = dict((k, fix_field(v)) for k, v in fields.items() if v is not None and v is not "")
    message="{0},{1} {2} {3}000000000".format(
        'bpf',
        ','.join(['{0}={1}'.format(k, v) for k,v in tags.items()]),
        ','.join(['{0}={1}'.format(k, v) for k,v in fields.items()]),
        int(time.time()))
    with threading.Lock():
        debug and print("> {0}".format(message))
        sock.sendall("{0}\n".format(message))

def collect_biolatency(bpfilter):
    bpfinfo = dict()
    bpfinfo['name'] = 'bpf'
    bpfinfo['fields'] = dict()
    bpfinfo['tags'] = dict()
    bpfinfo['tags']['sensor'] = 'biolatency'

    dist = bpfilter.get_table("dist")

    for key, value in dist.items():
        diskname = str(getattr(key, dist.Key._fields_[0][0]))
        lowerend = int(getattr(key, dist.Key._fields_[1][0]))

        if diskname:
            bpfinfo['tags']['disk'] = str(diskname)
        bpfinfo['tags']['le'] = 2**(lowerend - 1)
        bpfinfo['fields']['count'] = value.value
        send_message(bpfinfo['tags'], bpfinfo['fields'])
    dist.clear()

# cachestat
def collect_cachestat(bpfilter):
    bpfinfo = dict()
    bpfinfo['tags'] = dict()
    bpfinfo['tags']['sensor'] = 'cachestat'
    dist = bpfilter.get_table("dist")

    counts = dict.fromkeys(["mark_page_accessed", "mark_buffer_dirty", "add_to_page_cache_lru", "account_page_dirtied"], 0)
    for k, v in sorted(dist.items(), key=lambda dist: dist[1].value):
        func = bpfilter.ksym(k.ip)
        counts[func] = int(max(0, v.value))
    counts["total"] = counts["mark_page_accessed"] - counts["mark_buffer_dirty"]
    counts["misses"] = counts["add_to_page_cache_lru"] - counts["account_page_dirtied"]
    counts["hits"] = counts["total"] - counts["misses"]
    counts["misses"] = counts["total"] if counts["hits"] < 0 else counts["misses"]
    counts["hits"] = 0 if counts["hits"] < 0 else counts["hits"]

    send_message(bpfinfo['tags'], counts)
    dist.clear()

# execsnoop data structs
TASK_COMM_LEN = 16      # linux/sched.h
ARGSIZE = 128           # should match #define in C above

class DataExec(ct.Structure):
    _fields_ = [
        ("pid", ct.c_uint),
        ("ppid", ct.c_uint),
        ("uid", ct.c_uint32),
        ("comm", ct.c_char * TASK_COMM_LEN),
        ("type", ct.c_int),
        ("argv", ct.c_char * ARGSIZE),
        ("retval", ct.c_int),
    ]

class EventType(object):
    EVENT_ARG = 0
    EVENT_RET = 1

argv = defaultdict(list)

def collect_execsnoop(cpu, data, size):
    event = ct.cast(data, ct.POINTER(DataExec)).contents

    if event.type == EventType.EVENT_ARG:
        argv[event.pid].append(event.argv)
    elif event.type == EventType.EVENT_RET:
        ppid = event.ppid if event.ppid > 0 else -1
        argv_text = b' '.join(argv[event.pid]).replace(b'\n', b' ')
        bpfinfo = dict()
        bpfinfo['name'] = 'bpf'
        bpfinfo['fields'] = dict()
        bpfinfo['tags'] = dict()
        bpfinfo['tags']['sensor'] = 'execsnoop'
        bpfinfo['tags']['ppid'] = ppid
        bpfinfo['tags']['pid'] = int(event.pid)
        bpfinfo['tags']['uid'] = int(event.uid)
        bpfinfo['tags']['process'] = event.comm
        bpfinfo['fields']['retval'] = event.retval
        bpfinfo['fields']['argv_text'] = argv_text
        send_message(bpfinfo['tags'], bpfinfo['fields'])
        try:
            del(argv[event.pid])
        except Exception:
            pass

# opensnoop
NAME_MAX = 255        # linux/limits.h

class DataOpen(ct.Structure):
    _fields_ = [
        ("id", ct.c_ulonglong),
        ("ts", ct.c_ulonglong),
        ("uid", ct.c_uint32),
        ("ret", ct.c_int),
        ("comm", ct.c_char * TASK_COMM_LEN),
        ("fname", ct.c_char * NAME_MAX),
        ("flags", ct.c_int),
    ]

def collect_opensnoop(cpu, data, size):
    event = ct.cast(data, ct.POINTER(DataOpen)).contents

    # split return value into FD and errno columns
    if event.ret >= 0:
        fd_s = event.ret
        err = 0
    else:
        fd_s = -1
        err = - event.ret

    fname = event.fname
    if fname.startswith('/proc/'):
        return
    bpfinfo = dict()
    bpfinfo['name'] = 'bpf'
    bpfinfo['fields'] = dict()
    bpfinfo['tags'] = dict()
    bpfinfo['tags']['sensor'] = 'opensnoop'
    bpfinfo['tags']['errno'] = err
    bpfinfo['tags']['pid'] = int(event.id >> 32)
    bpfinfo['tags']['uid'] = int(event.uid)
    bpfinfo['tags']['fname'] = fname
    bpfinfo['tags']['process'] = event.comm
    bpfinfo['fields']['fd'] = fd_s
    bpfinfo['fields']['flags'] = "{0:08o}".format(event.flags)
    send_message(bpfinfo['tags'], bpfinfo['fields'])

# tcplife
class Data_ipv4(ct.Structure):
    _fields_ = [
        ("ts_us", ct.c_ulonglong),
        ("pid", ct.c_uint),
        ("saddr", ct.c_uint),
        ("daddr", ct.c_uint),
        ("ports", ct.c_ulonglong),
        ("rx_b", ct.c_ulonglong),
        ("tx_b", ct.c_ulonglong),
        ("span_us", ct.c_ulonglong),
        ("comm", ct.c_char * TASK_COMM_LEN),
        ("uid", ct.c_uint)
    ]

class Data_ipv6(ct.Structure):
    _fields_ = [
        ("ts_us", ct.c_ulonglong),
        ("pid", ct.c_uint),
        ("saddr", (ct.c_ulonglong * 2)),
        ("daddr", (ct.c_ulonglong * 2)),
        ("ports", ct.c_ulonglong),
        ("rx_b", ct.c_ulonglong),
        ("tx_b", ct.c_ulonglong),
        ("span_us", ct.c_ulonglong),
        ("comm", ct.c_char * TASK_COMM_LEN),
        ("uid", ct.c_uint)
    ]

# process event
def print_ipv4_event(cpu, data, size):
    event = ct.cast(data, ct.POINTER(Data_ipv4)).contents
    bpfinfo = dict()

    bpfinfo['fields'] = dict()
    bpfinfo['tags'] = dict()

    bpfinfo['tags']['sensor'] = 'tcplife'
    bpfinfo['tags']['pid'] = int(event.pid)
    bpfinfo['tags']['uid'] = int(event.uid)
    bpfinfo['tags']['process'] = event.comm
    bpfinfo['tags']['protocol'] = "ipv4"
    bpfinfo['tags']['laddr'] = socket.inet_ntop(socket.AF_INET, struct.pack("I", event.saddr))
    bpfinfo['tags']['lport'] = event.ports >> 32
    bpfinfo['tags']['raddr'] = socket.inet_ntop(socket.AF_INET, struct.pack("I", event.daddr))
    bpfinfo['tags']['rport'] = event.ports & 0xffffffff

    bpfinfo['fields']['tx_b'] = event.tx_b
    bpfinfo['fields']['rx_b'] = event.rx_b
    bpfinfo['fields']['duration'] = event.span_us # microseconds
    cid = communityid.CommunityID()
    tpl = communityid.FlowTuple.make_tcp(bpfinfo['tags']['laddr'],
        bpfinfo['tags']['raddr'],
        bpfinfo['tags']['lport'],
        bpfinfo['tags']['rport'])
    bpfinfo['tags']['communityid'] = cid.calc(tpl)
    send_message(bpfinfo['tags'], bpfinfo['fields'])

def print_ipv6_event(cpu, data, size):
    event = ct.cast(data, ct.POINTER(Data_ipv6)).contents
    bpfinfo = dict()

    bpfinfo['fields'] = dict()
    bpfinfo['tags'] = dict()

    bpfinfo['tags']['sensor'] = 'tcplife'
    bpfinfo['tags']['pid'] = int(event.pid)
    bpfinfo['tags']['uid'] = int(event.uid)
    bpfinfo['tags']['process'] = event.comm
    bpfinfo['tags']['protocol'] = "ipv6"
    bpfinfo['tags']['laddr'] = socket.inet_ntop(socket.AF_INET6, event.saddr)
    bpfinfo['tags']['lport'] = event.ports >> 32
    bpfinfo['tags']['raddr'] = socket.inet_ntop(socket.AF_INET6, event.daddr)
    bpfinfo['tags']['rport'] = event.ports & 0xffffffff

    bpfinfo['fields']['tx_b'] = event.tx_b
    bpfinfo['fields']['rx_b'] = event.rx_b
    bpfinfo['fields']['duration'] = event.span_us # microseconds
    cid = communityid.CommunityID()
    tpl = communityid.FlowTuple.make_tcp(bpfinfo['tags']['laddr'],
        bpfinfo['tags']['raddr'],
        bpfinfo['tags']['lport'],
        bpfinfo['tags']['rport'])
    bpfinfo['tags']['communityid'] = cid.calc(tpl)

    send_message(bpfinfo['tags'], bpfinfo['fields'])

def collector(config, subsystem):
    modname = subsystem[:-2].split('/')[-1]

    bpf_text = ""
    with open(subsystem, 'r') as fd:
        bpf_text = fd.read()
    b = BPF(text=bpf_text)

    try:
        for kprobe in config['collectors'][modname]['kprobes']:
            hook = kprobe.keys()[0]
            func = kprobe[hook]
            with threading.Lock():
                b.attach_kprobe(event=hook, fn_name=func)
    except KeyError:
        pass

    try:
        for kprobe in config['collectors'][modname]['kretprobes']:
            hook = kprobe.keys()[0]
            func = kprobe[hook]
            with threading.Lock():
                b.attach_kretprobe(event=hook, fn_name=func)
    except KeyError:
        pass

    # thought we were done with hacks? dj_khaled.jpg
    # need to break out the common pieces in the future...
    if modname in ["execsnoop", "opensnoop"]:
        b["events"].open_perf_buffer(globals()["collect_"+modname], page_cnt=64)
    if modname in ["tcplife"]:
        b["ipv4_events"].open_perf_buffer(print_ipv4_event, page_cnt=64)
        b["ipv6_events"].open_perf_buffer(print_ipv6_event, page_cnt=64)
    ticker = threading.Event()
    while not ticker.wait(5):
        if modname in ["execsnoop", "opensnoop", "tcplife"]:
            b.perf_buffer_poll()
        else:
            globals()["collect_"+modname](b)

def is_dir(path):
    if not os.path.isdir(path):
        raise argparse.ArgumentTypeError("Path is not a directory")
    else:
        return os.path.abspath(os.path.realpath(os.path.expanduser(path)))

def get_args():
    """Parses and returns arguments to the program"""

    yamlparse = configargparse.YAMLConfigFileParser

    parser = configargparse.ArgParser(default_config_files=['/etc/greggd/conf.yaml',
        '/etc/greggd/conf.d/*.conf',
        '/etc/greggd/conf.d/*.yaml'],
        args_for_setting_config_path=['-c', '--config'],
        config_file_parser_class=yamlparse)
    parser.add_argument(
        '-d',
        '--dir',
        type=str,
        help='Directory for C source queries',
        default='/usr/share/greggd/c')

    args = [x for x in parser.parse_known_args()]
    content = '\n'.join([fd.read() for fd in parser._open_config_files(args[0]._get_kwargs())])
    config = yaml.safe_load(content)

    # Return all variable values
    return args, config

if __name__ == '__main__':
    args, config = get_args()

    #TODO: change these hacks
    os.chdir("/usr/src/kernels/{0}".format(os.uname()[2]))
    sys.path.insert(0, '/tmp/bcc_collector')
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    try:
        sock.connect('/var/run/telegraf.sock')
    except socket.error, msg:
        sys.exit(1)
    threads = list()

    for fname in glob.glob("{0}/*.c".format(config['dir'])):
        t = threading.Thread(target=collector, args=(config, fname))
        threads.append(t)
        t.start()

